import "./chunk-V4OQ3NZ2.js";

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  return Uint8Array.of((v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v2 >>> 16 & 255, v2 >>> 8 & 255, v2 & 255, (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v2 / 4294967296 & 255, v2 >>> 24 & 255, v2 >>> 16 & 255, v2 >>> 8 & 255, v2 & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x2);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x2 = xpad;
  let a2 = 1732584193;
  let b2 = -271733879;
  let c = -1732584194;
  let d2 = 271733878;
  for (let i = 0; i < x2.length; i += 16) {
    const olda = a2;
    const oldb = b2;
    const oldc = c;
    const oldd = d2;
    a2 = md5ff(a2, b2, c, d2, x2[i], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c, x2[i + 1], 12, -389564586);
    c = md5ff(c, d2, a2, b2, x2[i + 2], 17, 606105819);
    b2 = md5ff(b2, c, d2, a2, x2[i + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c, d2, x2[i + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c, x2[i + 5], 12, 1200080426);
    c = md5ff(c, d2, a2, b2, x2[i + 6], 17, -1473231341);
    b2 = md5ff(b2, c, d2, a2, x2[i + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c, d2, x2[i + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c, x2[i + 9], 12, -1958414417);
    c = md5ff(c, d2, a2, b2, x2[i + 10], 17, -42063);
    b2 = md5ff(b2, c, d2, a2, x2[i + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c, d2, x2[i + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c, x2[i + 13], 12, -40341101);
    c = md5ff(c, d2, a2, b2, x2[i + 14], 17, -1502002290);
    b2 = md5ff(b2, c, d2, a2, x2[i + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c, d2, x2[i + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c, x2[i + 6], 9, -1069501632);
    c = md5gg(c, d2, a2, b2, x2[i + 11], 14, 643717713);
    b2 = md5gg(b2, c, d2, a2, x2[i], 20, -373897302);
    a2 = md5gg(a2, b2, c, d2, x2[i + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c, x2[i + 10], 9, 38016083);
    c = md5gg(c, d2, a2, b2, x2[i + 15], 14, -660478335);
    b2 = md5gg(b2, c, d2, a2, x2[i + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c, d2, x2[i + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c, x2[i + 14], 9, -1019803690);
    c = md5gg(c, d2, a2, b2, x2[i + 3], 14, -187363961);
    b2 = md5gg(b2, c, d2, a2, x2[i + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c, d2, x2[i + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c, x2[i + 2], 9, -51403784);
    c = md5gg(c, d2, a2, b2, x2[i + 7], 14, 1735328473);
    b2 = md5gg(b2, c, d2, a2, x2[i + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c, d2, x2[i + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c, x2[i + 8], 11, -2022574463);
    c = md5hh(c, d2, a2, b2, x2[i + 11], 16, 1839030562);
    b2 = md5hh(b2, c, d2, a2, x2[i + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c, d2, x2[i + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c, x2[i + 4], 11, 1272893353);
    c = md5hh(c, d2, a2, b2, x2[i + 7], 16, -155497632);
    b2 = md5hh(b2, c, d2, a2, x2[i + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c, d2, x2[i + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c, x2[i], 11, -358537222);
    c = md5hh(c, d2, a2, b2, x2[i + 3], 16, -722521979);
    b2 = md5hh(b2, c, d2, a2, x2[i + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c, d2, x2[i + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c, x2[i + 12], 11, -421815835);
    c = md5hh(c, d2, a2, b2, x2[i + 15], 16, 530742520);
    b2 = md5hh(b2, c, d2, a2, x2[i + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c, d2, x2[i], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c, x2[i + 7], 10, 1126891415);
    c = md5ii(c, d2, a2, b2, x2[i + 14], 15, -1416354905);
    b2 = md5ii(b2, c, d2, a2, x2[i + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c, d2, x2[i + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c, x2[i + 3], 10, -1894986606);
    c = md5ii(c, d2, a2, b2, x2[i + 10], 15, -1051523);
    b2 = md5ii(b2, c, d2, a2, x2[i + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c, d2, x2[i + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c, x2[i + 15], 10, -30611744);
    c = md5ii(c, d2, a2, b2, x2[i + 6], 15, -1560198380);
    b2 = md5ii(b2, c, d2, a2, x2[i + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c, d2, x2[i + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c, x2[i + 11], 10, -1120210379);
    c = md5ii(c, d2, a2, b2, x2[i + 2], 15, 718787259);
    b2 = md5ii(b2, c, d2, a2, x2[i + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c = safeAdd(c, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return Uint32Array.of(a2, b2, c, d2);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x2, y) {
  const lsw = (x2 & 65535) + (y & 65535);
  const msw = (x2 >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b2, x2, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x2, t)), s), b2);
}
function md5ff(a2, b2, c, d2, x2, s, t) {
  return md5cmn(b2 & c | ~b2 & d2, a2, b2, x2, s, t);
}
function md5gg(a2, b2, c, d2, x2, s, t) {
  return md5cmn(b2 & d2 | c & ~d2, a2, b2, x2, s, t);
}
function md5hh(a2, b2, c, d2, x2, s, t) {
  return md5cmn(b2 ^ c ^ d2, a2, b2, x2, s, t);
}
function md5ii(a2, b2, c, d2, x2, s, t) {
  return md5cmn(c ^ (b2 | ~d2), a2, b2, x2, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x2, y, z) {
  switch (s) {
    case 0:
      return x2 & y ^ ~x2 & z;
    case 1:
      return x2 ^ y ^ z;
    case 2:
      return x2 & y ^ x2 & z ^ y & z;
    case 3:
      return x2 ^ y ^ z;
  }
}
function ROTL(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l2 = bytes.length / 4 + 2;
  const N = Math.ceil(l2 / 16);
  const M2 = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[i * 64 + j2 * 4] << 24 | bytes[i * 64 + j2 * 4 + 1] << 16 | bytes[i * 64 + j2 * 4 + 2] << 8 | bytes[i * 64 + j2 * 4 + 3];
    }
    M2[i] = arr;
  }
  M2[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N - 1][14] = Math.floor(M2[N - 1][14]);
  M2[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M2[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a2 = H[0];
    let b2 = H[1];
    let c = H[2];
    let d2 = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T2 = ROTL(a2, 5) + f(s, b2, c, d2) + e + K[s] + W[t] >>> 0;
      e = d2;
      d2 = c;
      c = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T2;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d2 >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL;

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/ufo/dist/index.mjs
var r = String.fromCharCode;
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var SLASH_RE = /\//g;
var EQUAL_RE = /=/g;
var PLUS_RE = /\+/g;
var ENC_CARET_RE = /%5e/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_PIPE_RE = /%7c/gi;
var ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}
var PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
var PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
var PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
var TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
var JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s0, ...s] = path.split("?");
  const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
  return (cleanPath || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
var protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

// node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs
var FetchError = class extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if ((opts == null ? void 0 : opts.cause) && !this.cause) {
      this.cause = opts.cause;
    }
  }
};
function createFetchError(ctx) {
  var _a, _b, _c, _d, _e;
  const errorMessage = ((_a = ctx.error) == null ? void 0 : _a.message) || ((_b = ctx.error) == null ? void 0 : _b.toString()) || "";
  const method = ((_c = ctx.request) == null ? void 0 : _c.method) || ((_d = ctx.options) == null ? void 0 : _d.method) || "GET";
  const url = ((_e = ctx.request) == null ? void 0 : _e.url) || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}
var payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
var textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function resolveFetchOptions(request, input, defaults, Headers2) {
  const headers = mergeHeaders(
    (input == null ? void 0 : input.headers) ?? (request == null ? void 0 : request.headers),
    defaults == null ? void 0 : defaults.headers,
    Headers2
  );
  let query;
  if ((defaults == null ? void 0 : defaults.query) || (defaults == null ? void 0 : defaults.params) || (input == null ? void 0 : input.params) || (input == null ? void 0 : input.query)) {
    query = {
      ...defaults == null ? void 0 : defaults.params,
      ...defaults == null ? void 0 : defaults.query,
      ...input == null ? void 0 : input.params,
      ...input == null ? void 0 : input.query
    };
  }
  return {
    ...defaults,
    ...input,
    query,
    params: query,
    headers
  };
}
function mergeHeaders(input, defaults, Headers2) {
  if (!defaults) {
    return new Headers2(input);
  }
  const headers = new Headers2(defaults);
  if (input) {
    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers2(input)) {
      headers.set(key, value);
    }
  }
  return headers;
}
async function callHooks(context, hooks) {
  if (hooks) {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        await hook(context);
      }
    } else {
      await hooks(context);
    }
  }
}
var retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
var nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch: fetch2 = globalThis.fetch,
    Headers: Headers2 = globalThis.Headers,
    AbortController: AbortController2 = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = typeof context.options.retryDelay === "function" ? context.options.retryDelay(context) : context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: resolveFetchOptions(
        _request,
        _options,
        globalOptions.defaults,
        Headers2
      ),
      response: void 0,
      error: void 0
    };
    if (context.options.method) {
      context.options.method = context.options.method.toUpperCase();
    }
    if (context.options.onRequest) {
      await callHooks(context, context.options.onRequest);
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query) {
        context.request = withQuery(context.request, context.options.query);
        delete context.options.query;
      }
      if ("query" in context.options) {
        delete context.options.query;
      }
      if ("params" in context.options) {
        delete context.options.params;
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        context.options.body = typeof context.options.body === "string" ? context.options.body : JSON.stringify(context.options.body);
        context.options.headers = new Headers2(context.options.headers || {});
        if (!context.options.headers.has("content-type")) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController2();
      abortTimeout = setTimeout(() => {
        const error = new Error(
          "[TimeoutError]: The operation was aborted due to timeout"
        );
        error.name = "TimeoutError";
        error.code = 23;
        controller.abort(error);
      }, context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch2(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await callHooks(
          context,
          context.options.onRequestError
        );
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324
    // https://github.com/unjs/ofetch/issues/294
    // https://github.com/JakeChampion/fetch/issues/1454
    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body || context.response._bodyInit;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await callHooks(
        context,
        context.options.onResponse
      );
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await callHooks(
          context,
          context.options.onResponseError
        );
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r2 = await $fetchRaw(request, options);
    return r2._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch2(...args);
  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({
    ...globalOptions,
    ...customGlobalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...customGlobalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

// node_modules/ofetch/dist/index.mjs
var _globalThis = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}();
var fetch = _globalThis.fetch ? (...args) => _globalThis.fetch(...args) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!"));
var Headers = _globalThis.Headers;
var AbortController = _globalThis.AbortController;
var ofetch = createFetch({ fetch, Headers, AbortController });

// node_modules/@lumi.new/sdk/dist/index.mjs
var U = Object.defineProperty;
var R = Object.getOwnPropertySymbols;
var $ = Object.prototype.hasOwnProperty;
var j = Object.prototype.propertyIsEnumerable;
var P = (i) => {
  throw TypeError(i);
};
var v = (i, e, t) => e in i ? U(i, e, { enumerable: true, configurable: true, writable: true, value: t }) : i[e] = t;
var C = (i, e) => {
  for (var t in e || (e = {})) $.call(e, t) && v(i, t, e[t]);
  if (R) for (var t of R(e)) j.call(e, t) && v(i, t, e[t]);
  return i;
};
var M = (i, e, t) => e.has(i) || P("Cannot " + t);
var n = (i, e, t) => (M(i, e, "read from private field"), t ? t.call(i) : e.get(i));
var m = (i, e, t) => e.has(i) ? P("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, t);
var d = (i, e, t, r2) => (M(i, e, "write to private field"), r2 ? r2.call(i, t) : e.set(i, t), t);
var l = (i, e, t) => new Promise((r2, c) => {
  var s = (u) => {
    try {
      f2(t.next(u));
    } catch (y) {
      c(y);
    }
  }, h = (u) => {
    try {
      f2(t.throw(u));
    } catch (y) {
      c(y);
    }
  }, f2 = (u) => u.done ? r2(u.value) : Promise.resolve(u.value).then(s, h);
  f2((t = t.apply(i, e)).next());
});
function a(i, e, t = {}) {
  return i.auth.accessToken && (t.headers = C({ Authorization: `Bearer ${i.auth.accessToken}` }, t.headers)), ofetch(e, C({ baseURL: i.config.apiBaseUrl }, t));
}
function D() {
  var i, e;
  return (e = (i = document.querySelector('link[rel="icon"]')) == null ? void 0 : i.href) != null ? e : null;
}
function O() {
  var i;
  return (i = document.title) != null ? i : null;
}
function I(i, e, t = localStorage) {
  let r2 = t.getItem(i), c = e ? JSON.stringify(e) : null;
  c ? t.setItem(i, c) : t.removeItem(i), window.dispatchEvent(new StorageEvent("storage", { key: i, oldValue: r2, newValue: c, storageArea: t }));
}
function A(i, e = localStorage) {
  let t = e.getItem(i);
  try {
    return t ? JSON.parse(t) : null;
  } catch (r2) {
    return null;
  }
}
var g;
var T;
var E = class {
  constructor(e) {
    m(this, g);
    m(this, T, `lumi-auth-${v4_default()}`);
    d(this, g, e);
  }
  get accessToken() {
    return A("lumi-access-token");
  }
  set accessToken(e) {
    I("lumi-access-token", e);
  }
  get user() {
    return A("lumi-user");
  }
  set user(e) {
    I("lumi-user", e);
  }
  get isAuthenticated() {
    return !!this.accessToken;
  }
  signIn() {
    let r2 = (window.screen.width - 800) / 2, c = (window.screen.height - 600) / 2, s = window.open(n(this, g).config.authOrigin, n(this, T), `width=800,height=600,left=${r2},top=${c}`), h;
    return new Promise((f2, u) => {
      if (!s) return u(new Error("Open auth window failed"));
      let y = setInterval(() => {
        s.closed && u(new Error("Auth window closed"));
      }, 1e3), L = ({ data: p, origin: k, source: N }) => {
        if (!(k !== n(this, g).config.authOrigin || N !== s)) switch (p == null ? void 0 : p.type) {
          case "lumi-ready": {
            s.postMessage({ type: "lumi-init", data: { projectId: n(this, g).config.projectId, icon: D(), title: O() } }, n(this, g).config.authOrigin);
            break;
          }
          case "lumi-sign-in": {
            if (p.data.projectId !== n(this, g).config.projectId) break;
            s.close(), window.focus(), this.accessToken = p.data.accessToken, this.user = p.data.user, f2(p.data);
            break;
          }
        }
      };
      window.addEventListener("message", L), h = () => {
        clearInterval(y), window.removeEventListener("message", L);
      };
    }).finally(() => h == null ? void 0 : h());
  }
  signOut() {
    this.accessToken = null, this.user = null;
  }
  refreshUser() {
    return l(this, null, function* () {
      let e = yield a(n(this, g), "/lm/user/info", { method: "POST" });
      if (e.code !== 200) throw new Error(e.message);
      return this.user = e.data, e.data;
    });
  }
  onAuthChange(e) {
    let t = (r2) => {
      (r2.key === "lumi-access-token" || r2.key === "lumi-user" || r2.key === null) && e({ isAuthenticated: this.isAuthenticated, user: this.user });
    };
    return window.addEventListener("storage", t), () => {
      window.removeEventListener("storage", t);
    };
  }
};
g = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap();
var o;
var b = class {
  constructor(e, t) {
    m(this, o);
    d(this, o, e), this.entityName = t;
  }
  list() {
    return l(this, arguments, function* ({ filter: e, sort: t, limit: r2, skip: c } = {}) {
      if (r2) {
        let s = yield a(n(this, o), this.uri("/find"), { method: "POST", body: { filter: e, sort: t, limit: r2, skip: c } });
        if (s.code !== 200) throw new Error(s.message);
        return s.data;
      } else {
        let s = yield a(n(this, o), this.uri("/list"), { method: "POST", body: { filter: e, sort: t } });
        if (s.code !== 200) throw new Error(s.message);
        return { total: s.data.length, list: s.data };
      }
    });
  }
  get(e) {
    return l(this, null, function* () {
      let t = yield a(n(this, o), this.uri(`/${e}`), { method: "GET" });
      if (t.code !== 200) throw new Error(t.message);
      return t.data;
    });
  }
  create(e) {
    return l(this, null, function* () {
      let t = yield a(n(this, o), this.uri(), { method: "POST", body: e });
      if (t.code !== 200) throw new Error(t.message);
      return t.data;
    });
  }
  createMany(e) {
    return l(this, null, function* () {
      let t = yield a(n(this, o), this.uri("/batch"), { method: "POST", body: e });
      if (t.code !== 200) throw new Error(t.message);
      return t.data;
    });
  }
  update(e, t) {
    return l(this, null, function* () {
      let r2 = yield a(n(this, o), this.uri(), { method: "PUT", body: { filter: { _id: e }, update: t } });
      if (r2.code !== 200) throw new Error(r2.message);
      return r2.data;
    });
  }
  delete(e) {
    return l(this, null, function* () {
      let t = yield a(n(this, o), this.uri(`/${e}`), { method: "DELETE" });
      if (t.code !== 200) throw new Error(t.message);
    });
  }
  deleteMany(e) {
    return l(this, null, function* () {
      let t = yield a(n(this, o), this.uri("/batch-by-ids"), { method: "DELETE", params: { ids: e } });
      if (t.code !== 200) throw new Error(t.message);
    });
  }
  uri(e = "") {
    return `/lm/${n(this, o).config.projectId}/${this.entityName}/documents${e}`;
  }
};
o = /* @__PURE__ */ new WeakMap();
var w;
var S = class {
  constructor(e) {
    m(this, w);
    return d(this, w, e), new Proxy(this, { get(t, r2) {
      return r2 in t || (t[r2] = new b(n(t, w), r2)), t[r2];
    } });
  }
};
w = /* @__PURE__ */ new WeakMap();
var x = class {
  constructor(e) {
    this.config = e, this.auth = new E(this), this.entities = new S(this);
  }
};
function ae(i) {
  return new x(i);
}
export {
  S as EntitiesClient,
  b as EntityClient,
  E as LumiAuthClient,
  x as LumiClient,
  ae as createClient
};
//# sourceMappingURL=@lumi__new_sdk.js.map
